levels of board states (with rating in parentheses):
three in a row (horizontally, vertically, diagonally): (3)
two in a row (horizontally, vertically, diagonally): (2)
two with a space in between (horizontally, vertically, diagonally): (2)
a lone mark: (1)

Marks (Class): // cdould probably just do integers and not even use a class, class would just provide more information if we need it.
row: int
column: int
player: int (?)
type: String (?)

Grid (Class):
tiles: Marks[][] (or 2D list)
numMarks: int
setMark(Mark, row, col): void
computeState(): int  // return the "static evaluation of the position"

//===========================================================================
// How to get the static evaluation of the position?

// we can't just sum all of the values of the grid up, as the evaluation would
// always equal either -1 or +1, depending on whether the human player is an
// X or O since Tic-Tac-Toe alternates turns between both players.

// *******************************************************************************
// this block was brainstorming that I don't think will work, and have a better 
// idea later, but I still decided to leave this in.
//*********************************************************************************
// if iterating over each tile, might need a way of reducing redundancies
// i.e. X| |X
//      -----
//       | |
//      -----
//      X| | 
// if iterating over each tile, then the top row's favorable state of two with a
//  space between would be counted twice; same with the diagonal and vertical
//  sequences.
//  Does this even matter? Would redundancies create some kind of extra weighting?
//***************************************************************************

// This might be the better solution?
// Maybe each row, column and diagonal could be evaluated.
// I think the ordering of favorable game states above might mean that you could simply
// sum the "values" of player marks when taking this approach; such as if X is the maximizer, we could assign every
// X the value of 1. Then that would make O the minimizer and we could assign every O
// the value of -1. a blank tile would just have a value of 0 (might not even be necessary).

// i.e. X|0|X
//      -----
//       |0|
//      -----
//      X| | 
// In this example, X is the maximizer (therefore has a multiplier of +1), and O is the minimizer (and 
//  has a multiplier of -1).
// The first row is evaluated. Since there are two X's (for a total value of 2), and one O (for a total value of -1), and so this row gets a
//  value of 1. the second row is evaluated, and has a value of -1. the third row has a value of 1.
//  The first column is evaluated. It has two X's, for a value of +2. the second row has a value of -2, and the third row has a value of +1.
//  The top-left -> bottom-right diagonal is evaluated, and has a value of 0. the other diagonal is evaluated, and has a total value of +1.
//  So, in total, this board state evaluation would be 1-1+1+2-2+1+0+1 = 3.

minimax() has a concept of "position", which I guess is the game board? "position"s are structured in a tree graph,
and have n children, where n is the number of possible moves a player can choose from to take.
That being said, the more Marks there are on the board, the less children are available; which is proportional to the number
of empty tiles on the board. At depth 0 (the root position), there are 9 possible moves, at depth 1, there are 8 possible moves, etc. 

BoardPosition (Class):
    depth: int (?)
    move (?) -> this is the move that is being represented in this position (board state). i.e. placing an X at (2, 1).
    children: Position[] (or list)

- is 9 possible at depth 0 (9 empty tiles) or is minimax called when the human player makes a move; meaning there would be only 8 tiles to choose from (8 children)